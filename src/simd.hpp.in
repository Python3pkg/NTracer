#ifndef simd_hpp
#define simd_hpp

#include <cstdint>
#include <cmath>

#ifdef __GNUC__
    #ifdef __GNUC_GNU_INLINE__
        #define FORCE_INLINE(RET) inline RET __attribute__((gnu_inline,always_inline))
    #else
        #define FORCE_INLINE(RET) inline RET __attribute__((always_inline))
    #endif
#elif defined(_MSC_VER)
    #define FORCE_INLINE(RET) __forceinline RET
#else
    #define FORCE_INLINE(RET) inline RET
#endif


// #if defined(?)
//     #define SUPPORT_AVX_512
//     #include <zmmintrin.h>
// #endif

// #if defined(?)
//     #define SUPPORT_FMA
// #endif

#if defined(__AVX2__)
    #define SUPPORT_AVX2
#endif

#if defined(__AVX__)
    #define SUPPORT_AVX
#endif

#if defined(SUPPORT_FMA) || defined(SUPPORT_AVX2) || defined(SUPPORT_AVX)
    #include <immintrin.h>
#endif

#if defined(__SSE4_2__)
    #define SUPPORT_SSE4_2
    #include <nmmintrin.h>
#endif

#if defined(__SSE4_1__)
    #define SUPPORT_SSE4_1
    #include <smmintrin.h>
#endif

#if defined(__SSSE3__)
    #define SUPPORT_SSSE3
    #include <tmmintrin.h>
#endif

#if defined(__SSE3__)
    #define SUPPORT_SSE3
    #include <pmmintrin.h>
#endif

#if defined(__SSE2__) || (defined(_M_IX86_FP) && _M_IX86_FP >= 2)
    #define SUPPORT_SSE2
    #include <emmintrin.h>
#endif

#if defined(__SSE__) || (defined(_M_IX86_FP) && _M_IX86_FP >= 1)
    #define SUPPORT_SSE
    #include <xmmintrin.h>
#endif


namespace simd {
    namespace impl {
        template<typename T,typename Packed,typename Item> struct common {
            typedef Item item_t;
            
            static const size_t size = sizeof(Packed) / sizeof(Item);
            
            Item &operator[](size_t i) {
                return data.s[i];
            }
            
            Item operator[](size_t i) const {
                return data.s[i];
            }
            
            template<typename F> T apply(F f) const {
                T r;
                for(int i=0; i<size; ++i) r.data.s[i] = f(data.s[i]);
                return r;
            }
            
            union {
                Packed p;
                Item s[size];
            } data;
            
            // fall-back implementations for missing SIMD functions
            T abs() const { return apply(std::abs); }
        };
        
        template<typename T,typename Packed,typename Item> struct common_real : common<T,Packed,Item> {
            // fall-back implementations for missing SIMD functions
            T add_sub(T b) const {
                static_assert(size % 2 == 0,"this algorithm assumes there is an even number of elements");
                
                T r;
                for(int i=0; i<size; i+=2) {
                    r.data.s[i] = data.s[i] + b.data.s[i];
                    r.data.s[i+1] = data.s[i+1] - b.data.s[i-1];
                }
                return r;
            }
            
            T ceil() const { return apply(std::ceil); }
            T floor() const { return apply(std::floor); }
        };
    }
    
    template<typename T,typename Size> struct _v_type {};
    
#ifdef SUPPORT_AVX_512
    struct double_v_512 : impl::common_real<double_v_512,__m512d,double> {
        double_v_512(__m512d _data) { data.p = _data; }
        
        // [[[double-512]]]
    };
    struct float_v_512 : impl::common_real<float_v_512,__m512,float> {
        float_v_512(__m512 _data) { data.p = _data; }
        
        // [[[float-512]]]
    };
    struct int64_v_512 : impl::common<int64_v_512,__m512i,int64_t> {
        int64_v_512(__m512i _data) { data.p = _data; }
        
        // [[[int64_t-512]]]
    };
    struct int32_v_512 : impl::common<int32_v_512,__m512i,int32_t> {
        int32_v_512(__m512i _data) { data.p = _data; }
        
        // [[[int32_t-512]]]
    };
    
    template<> struct _v_type<double,8> struct _v_type { typedef double_v_512 type; };
    template<> struct _v_type<float,16> struct _v_type { typedef float_v_512 type; };
    template<> struct _v_type<int64_t,8> struct _v_type { typedef int64_v_512 type; };
    template<> struct _v_type<int32_t,16> struct _v_type { typedef int32_v_512 type; };
#endif
    
#ifdef SUPPORT_AVX2
    struct int64_v_256 : impl::common<int64_v_256,__m256i,int64_t> {
        int64_v_256(__m256i _data) { data.p = _data; }
        
        // [[[int64_t-256]]]
    };
    struct int32_v_256 : impl::common<int32_v_256,__m256i,int32_t> {
        int32_v_256(__m256i _data) { data.p = _data; }
        
        // [[[int32_t-256]]]
    };
    struct int16_v_256 : impl::common<int16_v_256,__m256i,int16_t> {
        int16_v_256(__m256i _data) { data.p = _data; }
        
        // [[[int16_t-256]]]
    };
    struct int8_v_256 : impl::common<int8_v_256,__m256i,int8_t> {
        int8_v_256(__m256i _data) { data.p = _data; }
        
        // [[[int8_t-256]]]
    };
    
    template<> struct _v_type<int64_t,4> struct _v_type { typedef int64_v_256 type; };
    template<> struct _v_type<int32_t,8> struct _v_type { typedef int32_v_256 type; };
    template<> struct _v_type<int16_t,16> struct _v_type { typedef int16_v_256 type; };
    template<> struct _v_type<int8_t,32> struct _v_type { typedef int8_v_256 type; };
#endif

#ifdef SUPPORT_AVX
    struct double_v_256 : impl::common_real<double_v_256,__m256d,double> {
        double_v_256(__m256d _data) { data.p = _data; }
        
        // [[[double-256]]]
    };
    struct float_v_256 : impl::common_real<float_v_256,__m256,float> {
        float_v_256(__m256 _data) { data.p = _data; }
        
        // [[[float-256]]]
    };
    
    template<> struct _v_type<double,4> struct _v_type { typedef double_v_256 type; };
    template<> struct _v_type<float,8> struct _v_type { typedef float_v_256 type; };
#endif
    
#ifdef SUPPORT_SSE2
    struct double_v_128 : impl::common_real<double_v_128,__m128d,double> {
        double_v_128(__m128d _data) { data.p = _data; }
        
        // [[[double-128]]]
    };
    struct int64_v_128 : impl::common<int64_v_128,__m128i,int64_t> {
        int64_v_128(__m128i _data) { data.p = _data; }
        
        // [[[int64_t-128]]]
    };
    struct int32_v_128 : impl::common<int32_v_128,__m128i,int32_t> {
        int32_v_128(__m128i _data) { data.p = _data; }
        
        // [[[int32_t-128]]]
    };
    struct int16_v_128 : impl::common<int16_v_128,__m128i,int16_t> {
        int16_v_128(__m128i _data) { data.p = _data; }
        
        // [[[int16_t-128]]]
    };
    struct int8_v_128 : impl::common<int8_v_128,__m128i,int8_t> {
        int8_v_128(__m128i _data) { data.p = _data; }
        
        // [[[int8_t-128]]]
    };
    
    template<> struct _v_type<double,2> struct _v_type { typedef double_v_128 type; };
    template<> struct _v_type<int64_t,2> struct _v_type { typedef int64_v_128 type; };
    template<> struct _v_type<int32_t,4> struct _v_type { typedef int32_v_128 type; };
    template<> struct _v_type<int16_t,8> struct _v_type { typedef int16_v_128 type; };
    template<> struct _v_type<int8_t,16> struct _v_type { typedef int8_v_128 type; };
#endif
    
#ifdef SUPPORT_SSE
    struct float_v_128 : impl::common_real<float_v_128,__m128,float> {
        float_v_128(__m128 _data) { data.p = _data; }
        
        // [[[float-128]]]
    };
    
    template<> struct _v_type<float,4> struct _v_type { typedef float_v_128 type; };
#endif
    
    template<typename T> scalar {
        scalar(T data) : data(data) {}
        
        static const size_t size = 1;
        
        scalar<T> operator+(scalar<T> b) const { return data + b.data; }
        scalar<T>& operator+=(scalar<T> b) { data += b.data; return *this; }
        
        scalar<T> operator-(scalar<T> b) const { return data - b.data; }
        scalar<T>& operator-=(scalar<T> b) { data -= b.data; return *this; }
        
        scalar<T> operator&(scalar<T> b) const { return data & b.data; }
        scalar<T>& operator&=(scalar<T> b) { data &= b.data; return *this; }
        
        scalar<T> operator|(scalar<T> b) const { return data | b.data; }
        scalar<T>& operator|=(scalar<T> b) { data |= b.data; return *this; }
        
        scalar<T> operator^(scalar<T> b) const { return data ^ b.data; }
        scalar<T>& operator^=(scalar<T> b) { data ^= b.data; return *this; }

        T &operator[](size_t i) {
            assert(i == 0);
            return data;
        }
        
        T operator[](size_t i) const {
            assert(i == 0);
            return data;
        }
        
        template<typename F> scalar<T> apply(F f) const {
            return scalar<T>(f(data));
        }
        
        scalar<T> abs() const { return std::abs(data); }
        
        T reduce_max() const { return data; }
        T reduce_min() const { return data; }
        T reduce_add() const { return data; }
        
        T data;
    };
    
    template<typename T> scalar_real : scalar<T> {
        scalar_real(T data) : scalar(data) {}
        
        scalar<T> operator*(scalar<T> b) const { return data * b.data; }
        scalar<T>& operator*=(scalar<T> b) { data *= b.data; return *this; }
        
        scalar<T> operator/(scalar<T> b) const { return data / b.data; }
        scalar<T>& operator/=(scalar<T> b) { data /= b.data; return *this; }
        
        scalar_real<T> sqrt() const { return std::sqrt(data); }
        scalar_real<T> rsqrt() const { return T(1) / std::sqrt(data); }
        scalar_real<T> ceil() const { return std::ceil(data); }
        scalar_real<T> floor() const { return std::floor(data); }
    };
    
    typedef scalar_real<double> double_s;
    typedef scalar_real<float> float_s;
    typedef scalar<int64_t> int64_s;
    typedef scalar<int32_t> int32_s;
    typedef scalar<int16_t> int16_s;
    typedef scalar<int8_t> int8_s;


    template<> struct _v_type<double,1> struct _v_type { typedef scalar_real<double> type; };
    template<> struct _v_type<float,1> struct _v_type { typedef scalar_real<float> type; };
    template<> struct _v_type<int64_t,1> struct _v_type { typedef scalar<int64_t> type; };
    template<> struct _v_type<int32_t,1> struct _v_type { typedef scalar<int32_t> type; };
    template<> struct _v_type<int16_t,1> struct _v_type { typedef scalar<int16_t> type; };
    template<> struct _v_type<int8_t,1> struct _v_type { typedef scalar<int8_t> type; };
    
    
    // [[[functions]]]
}

#endif

